Joshua Lange and Reiner Liman
CIS*4650
Checkpoint #2
Date of Last Modification: Monday, March 20th, 2019

===================
Program Description
===================

This program takes in a C-minus program as input. The program should be reasonably well
formatted,error checking has been completed. A scanner reads in the input, and 
a parser generates a syntax tree. After this, the semantic analyzer works alongside the
symbol table to analyze the semantic meaning of the abstract syntax tree that has been 
generated by the scanner and the parser. The code has been designed based off of the code provided
to us by Dr. Song, and has implemented the visitor pattern using the AST tree template provided
in class. The final output of the abstract syntax tree is either a) a syntax tree of 
the input file, or 2) an error report from a fatal error. Some errors, we believe, were 
not recoverable from, given the scope and time available for this assignment. The final
output for the semantic analyzer is a similarly structured tree, however its contents is
the semantic analysis of the input program. Errors are generated inline with the output
of the tree, left-aligned, so as to show exactly where in the sequence the issue arises at.

======================================
Building Instructions and Testing Plan
======================================

This program uses both jflex and CUP as part of the application. These must be installed on
your system for the build to be successful. These build instructions also assume that javac is
a usable command on your computer, and that you are building on a Linux environment.

This program uses a makefile to build the program. Type 'make' in the top directory of this 
program's file structure to build the program. To remove the executable and intermediate files 
generated from compilation, type "make clean".

Turning on and off of both the semantic analyzer and the parse tree is completed through a toggle
option found in the CM.java file. This was completed in this way to keep it simple until the end
of Checkpoint 3, where the flags will isntead be used to determine whether or not a component 
works or not.

Testing has been automated into separate test files to test different components of the code. There
are five test files used for this program, as this was the maximum number of test files that we
were allowed to submit. These tests, therefore, attempt to show both the functionality and the error
recovery abilities of the program to the best of their ability, while also being limited to the
number of errors that can be shown (max. 3 per file). The fifth file has no restrictions on the
number of errors that can be contained in it, and has been filled with as many errors as possible.
These tests include both positive and negative test cases to show off both correct and incorrect
code structures. The files are listed below with a short description of what is contained inside of them:


   1) 1.cm: This is a modified version of the sort.cm that was provided for use by the professor. This file has been created to have no error. This was inentionally to show off a perfect runtime situation
   of our semantic analyzer.
        
   2) 2.cm: This is a modified version of the fac.cm that was provided to us for use by the professor.
      The errors included in this are as follows:
        - unused function prototype found at the end of the file
        - a used function prototype without a function definition 
      The errors in this file show the implementation and error checking of function prototypes
      and function definitions. While there are limitations with this implementation, functionality
      and error checking has been implemented, and has been shown through this test file.

   3) 3.cm: This is another modified version of the fac.cm that was provided to us for use by the professor. 
      The errors included in this are as follows:
        - an operation with a non-integer value on the right hand side
        - an undefined variable and a function reference
        - test expressions are not of type int

   4) 4.cm: This is a modified version for gcd.cm that was provided to us by the professor. The
      errors included are as follows:
        - non-integer array index
        - redefinition of a variable
        - return and function calls are of the wrong type

   5) 5.cm: This is a modified version of sort.cm that was provided to us for use by the professor.
      The errors included in this file are as follows:
        - unused function prototype found at the end of the file
        - a used function prototype without a function definition 
        - an operation with a non-integer value on the right hand side
        - an undefined variable and a function reference
        - test expressions are not of type int
        - non-integer array index
        - redefinition of a variable
        - return and function calls are of the wrong type


-Makefile to Run Tests-

These test files can be run through the makefile through using the following commands:

1)  make test1: runs the first test case
2)  make test2: runs the second test case
3)  make test3: runs the third test case
4)  make test4: runs the fourth test case
5)  make test5: runs the fifth test case


-Makefile to Run Tests from Checkpoint 1-

The tests from Checkpoint 1 have been deprecated to follow the naming convention
for the testing files noted in Checkpoint 2, but can still be used with the makefile:

1) make C1Test1: runs the first test case from Checkpoint 1
2) make C1Test2: runs the second test case from Checkpoint 1
3) make C1Test3: runs the third test case from Checkpoint 1
4) make C1Test4: runs the fourth test case from Checkpoint 1
5) make C1Test5: runs the fifth test case from Checkpoint 1

===========================
Assumptions and Limitations
===========================

1. We assume that the files provided will be in the .cm style, and have reasonable errors. Some
   error handling has been implemented, but definitely not enough to cover all possible error cases.
2. We assume that nothing outside of the assigment specification will be provided as input into the
   program, unless it is a reasonable test case for the scanner/parser.
3. This program will run perfectly on a program that is properly formatted.
4. This program does not handle cases where a variable not declared, but is then used in the program.
5. The program will not recognize a variable input when it is expecting a number. Rather, it will just
   crash. This is because we use ParseInt.
6. We assume that all function definitions and prototypes are defined in the global scope. Functions 
   defined in a scope lower than global are not valid and might cause unexpected behaviour when 
   the program runs.
7. We assume that there will not be nested function calls within the parameters of a function call.
    ex. returnValue = functionCall(x,y,newFunctionCall(z));
   This limitation exists because of the grammar specified in the CUP file. Having this functionality
   would potentially require that the program handles recursion, which is outside of the assignment scope.
8. Design decision: As a design decision, we have placed all errors involving function prototypes and
   function definitions at the end of the runttime. This means that, if a prototype exists and a call is
   made before a definition is found, the error is supressed until the end of the program. This is to
   make sure that a function definition that exists can be found, otherwise an error should be reported.
9. We assume that there will not be any dangling "return" in the global scope. This goes against the
   C- specification, and is not handled by our semantic analyzer.
10. Our program is super strict and will report everything that is wrong with the program. This might 
   cause some pieces of code to have multiple errors generated for it. We decided that this was the best 
   in terms of design because it would allow for the user of the compiler to recognize all of the mistakes
   that were associated with that piece of code, instead of having to recompile to notice an error that
   existed before, but was suppressed because another one had precedence. Thus, we have decided to 
   report all errors.

===================
Future Improvements
===================

Given additional work hours for this assignment, the following changes would have been implemented:

1. Additional error handling could be implemented, given more time. This includes a wider range of 
   error handling, as well as better handling of all errors when they occur. Some of the unrecoverable
   errors could be handled in a different way, or could be skipped, or even some basic spelling modifications
   could be reported, once the symbol table has been set up.
2. Additional simplification of the program could be completed using associations and combining
   grammar rules.  
3. 
